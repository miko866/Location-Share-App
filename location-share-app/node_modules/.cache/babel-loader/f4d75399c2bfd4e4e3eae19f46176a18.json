{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { whichButtons, getOffsetPosition } from './event-utils';\n\nvar EventRegistrar = function () {\n  function EventRegistrar(eventManager) {\n    _classCallCheck(this, EventRegistrar);\n\n    this.eventManager = eventManager;\n    this.handlers = [];\n    this.handlersByElement = new Map();\n    this.handleEvent = this.handleEvent.bind(this);\n  }\n\n  _createClass(EventRegistrar, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.handlers.length === 0;\n    }\n  }, {\n    key: \"add\",\n    value: function add(type, handler) {\n      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'root';\n      var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var handlers = this.handlers,\n          handlersByElement = this.handlersByElement;\n\n      if (!handlersByElement.has(srcElement)) {\n        handlersByElement.set(srcElement, []);\n      }\n\n      var entry = {\n        type: type,\n        handler: handler,\n        srcElement: srcElement,\n        once: once\n      };\n      handlers.push(entry);\n      handlersByElement.get(srcElement).push(entry);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(type, handler) {\n      var handlers = this.handlers,\n          handlersByElement = this.handlersByElement;\n\n      for (var i = handlers.length - 1; i >= 0; i--) {\n        var entry = handlers[i];\n\n        if (entry.type === type && entry.handler === handler) {\n          handlers.splice(i, 1);\n          var entries = handlersByElement.get(entry.srcElement);\n          entries.splice(entries.indexOf(entry), 1);\n\n          if (entries.length === 0) {\n            handlersByElement[\"delete\"](entry.srcElement);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      if (this.isEmpty()) {\n        return;\n      }\n\n      var mjolnirEvent = this._normalizeEvent(event);\n\n      var target = event.srcEvent.target;\n\n      while (target && target !== mjolnirEvent.rootElement) {\n        this._emit(mjolnirEvent, target);\n\n        if (mjolnirEvent.handled) {\n          return;\n        }\n\n        target = target.parentNode;\n      }\n\n      this._emit(mjolnirEvent, 'root');\n    }\n  }, {\n    key: \"_emit\",\n    value: function _emit(event, srcElement) {\n      var entries = this.handlersByElement.get(srcElement);\n\n      if (entries) {\n        var immediatePropagationStopped = false;\n\n        var stopPropagation = function stopPropagation() {\n          event.handled = true;\n        };\n\n        var stopImmediatePropagation = function stopImmediatePropagation() {\n          event.handled = true;\n          immediatePropagationStopped = true;\n        };\n\n        var entriesToRemove = [];\n\n        for (var i = 0; i < entries.length; i++) {\n          var _entries$i = entries[i],\n              type = _entries$i.type,\n              handler = _entries$i.handler,\n              once = _entries$i.once;\n          handler(Object.assign({}, event, {\n            type: type,\n            stopPropagation: stopPropagation,\n            stopImmediatePropagation: stopImmediatePropagation\n          }));\n\n          if (once) {\n            entriesToRemove.push(entries[i]);\n          }\n\n          if (immediatePropagationStopped) {\n            break;\n          }\n        }\n\n        for (var _i = 0; _i < entriesToRemove.length; _i++) {\n          var _entriesToRemove$_i = entriesToRemove[_i],\n              type = _entriesToRemove$_i.type,\n              handler = _entriesToRemove$_i.handler;\n          this.remove(type, handler);\n        }\n      }\n    }\n  }, {\n    key: \"_normalizeEvent\",\n    value: function _normalizeEvent(event) {\n      var rootElement = this.eventManager.element;\n      return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n        handled: false,\n        rootElement: rootElement\n      });\n    }\n  }]);\n\n  return EventRegistrar;\n}();\n\nexport { EventRegistrar as default };","map":{"version":3,"sources":["../../../src/utils/event-registrar.js"],"names":["EventRegistrar","type","handler","srcElement","once","handlers","handlersByElement","entry","i","entries","event","mjolnirEvent","target","immediatePropagationStopped","stopPropagation","stopImmediatePropagation","entriesToRemove","rootElement","whichButtons","getOffsetPosition","handled"],"mappings":"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","sourcesContent":["import {whichButtons, getOffsetPosition} from './event-utils';\n\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n\n    this.handleEvent = this.handleEvent.bind(this);\n  }\n\n  isEmpty() {\n    return this.handlers.length === 0;\n  }\n\n  add(type, handler, srcElement = 'root', once = false) {\n    const {handlers, handlersByElement} = this;\n\n    if (!handlersByElement.has(srcElement)) {\n      handlersByElement.set(srcElement, []);\n    }\n    const entry = {type, handler, srcElement, once};\n    handlers.push(entry);\n    handlersByElement.get(srcElement).push(entry);\n  }\n\n  remove(type, handler) {\n    const {handlers, handlersByElement} = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n  }\n\n  /**\n   * Handles hammerjs event\n   */\n  handleEvent(event) {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    const mjolnirEvent = this._normalizeEvent(event);\n    let target = event.srcEvent.target;\n\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n      if (mjolnirEvent.handled) {\n        return;\n      }\n      target = target.parentNode;\n    }\n    this._emit(mjolnirEvent, 'root');\n  }\n\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false;\n\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {type, handler, once} = entries[i];\n        handler(\n          Object.assign({}, event, {\n            type,\n            stopPropagation,\n            stopImmediatePropagation\n          })\n        );\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {type, handler} = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.element;\n\n    return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n      handled: false,\n      rootElement\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}